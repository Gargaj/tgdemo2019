<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Rainbow Butterfly</title>
		<meta charset="utf-8">
		<style>
			body {
				background-color: black;
			}
			canvas {
				position: absolute;
				top: 50%;
				margin-top: -400px;
				left: 50%;
				margin-left: -400px;
				height: 800px;
				width: 800px;
			}
		</style>
	</head>

	<body>
 		<script src="build/three.js"></script>
		<script src="js/libs/inflate.min.js"></script>
		<script src="js/loaders/FBXLoader.js"></script>
		<script src="js/WebGL.js"></script>
		<script src="src/PointAtMeshVertices.js"></script>

		<!-- post effekt-->
		<script src="js/shaders/CopyShader.js"></script>
		<script src="js/shaders/AfterimageShader.js"></script>
		<script src="js/shaders/DigitalGlitch.js"></script>

		<script src="js/postprocessing/EffectComposer.js"></script>
		<script src="js/postprocessing/RenderPass.js"></script>
		<script src="js/postprocessing/MaskPass.js"></script>
		<script src="js/postprocessing/ShaderPass.js"></script>
		<script src="js/postprocessing/AfterimagePass.js"></script>
		<script src="js/postprocessing/GlitchPass.js"></script>

		<script src="js/shaders/LuminosityHighPassShader.js"></script>
		<script src="js/postprocessing/UnrealBloomPass.js"></script>
		<!-- /post effekt-->


		<script>
			if ( WEBGL.isWebGLAvailable() === false ) {
				document.body.appendChild( WEBGL.getWebGLErrorMessage() );
			}
			var container;
			var camera, scene, renderer;
			var clock = new THREE.Clock();
			var mixer;

            var points = [];

            var butterfly;
            var composer;
            var renderPass;
            var glitchPass;
            var analyser;
            var sound;

            var timeline = [
				{
				    'activated': false,
					'startTime': 3
				},
                {
                    'activated': false,
                    'startTime': 3.5
                },
                {
                    'activated': false,
                    'startTime': 10
                },
                {
                    'activated': false,
                    'startTime': 30
                }
			];

			init();

			function init() {
				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 1000 );
				camera.position.set(40, 0, 0);
                camera.lookAt(0, 0, 0);

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x000000 );

				light = new THREE.HemisphereLight( 0xffffff, 0x444444 );
				light.position.set( 0, 200, 0 );
				scene.add( light );
				light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 0, 200, 100 );
				scene.add( light );

				//sound

                var listener = new THREE.AudioListener();
                camera.add( listener );
                sound = new THREE.Audio( listener );

                var audioLoader = new THREE.AudioLoader();

                sound.crossOrigin = 'anonymous';
                audioLoader.load( 'assets/Shuffle.wav', function( buffer ) {
                    sound.setBuffer( buffer );
                    sound.setLoop(false);
                    sound.setVolume(0.1);
                    sound.play();
                });

                sound.loop = false;

                analyser = new THREE.AudioAnalyser( sound, 32 );
                //analyser.getAverageFrequency()

                loadButterfly();
                renderer = new THREE.WebGLRenderer( { antialias: true } );
                //renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize(800, 800 );
                renderer.shadowMap.enabled = true;
                container.appendChild( renderer.domElement );

			}
            var afterimagePass;
			var bloomPass;
			function addRenderObjects () {
                composer = new THREE.EffectComposer( renderer );

                renderPass = new THREE.RenderPass( scene, camera );
                composer.addPass(renderPass);
                renderPass.enderToScreen = true;

                afterimagePass = new THREE.AfterimagePass();
                composer.addPass( afterimagePass );
                afterimagePass.uniforms.damp.value = 0.96;


                bloomPass = new THREE.UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
                bloomPass.threshold = 1;
                bloomPass.strength = 2;

                composer.addPass( bloomPass );

                animate();

            }

			function loadButterfly () {
                var material = new THREE.MeshBasicMaterial({
                    color: 0xeeeeee,
                    wireframe: true,
                    visible: true
                });

			    // model
                var loader = new THREE.FBXLoader();
                loader.crossOrigin = 'anonymous';
                loader.load( 'anim/butterfly_anim_v006.fbx', function ( object ) {
                    mixer = new THREE.AnimationMixer( object );
                    var action = mixer.clipAction( object.animations[ 0 ] );
                    action.play();

                    butterfly = object;

					object.traverse( function ( child ) {
                        if ( child.isMesh ) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            child.material = material;

							//var pointArray = child.geometry.attributes.position;
							//placePoints(pointArray, child);

                        } else if ( child instanceof THREE.Camera ) {
                            camera = child;

                            addRenderObjects ()
                        }
                    } );

                    scene.add( object );
                } );
			}

            function placePoints(allpointPositions, child) {
                // geometry
                var geometry = new THREE.BufferGeometry();

                // attributes
                var positions = new Float32Array( allpointPositions.array.length); // 3 values per vertex
                var rotations = new Float32Array( allpointPositions.array.length); // 1 values per vertex
                var colors = [];

				// colors
				var color = new THREE.Color();
				for ( var i = 0; i < allpointPositions.array.length; i++) {

					var r = 1;//Math.random();
					var g = 0.75;//Math.random();
					var b = 0.5;//Math.random();
					color.setHSL(allpointPositions.array[i*3] % 1, 1, 0.5);
					colors.push( color.r, color.g, color.b );
				}

                geometry.addAttribute( 'position', new THREE.BufferAttribute( allpointPositions.array, 3) );
				geometry.addAttribute( 'rotation', new THREE.BufferAttribute( rotations, 1 ) );
				geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );

                // material
				if (child.name.includes("Wing")) {
                	var material = new THREE.PointsMaterial( {
                    	vertexColors: THREE.VertexColors,
                    	size: 0.05,
                    	map: null
                	} );

                	// points
                	var childePoints = new THREE.Points( geometry, material )
                	var childePoints = new THREE.Points( geometry, material )


					for ( var i = 0; i < allpointPositions.array.length; i++) {
						allpointPositions.array[i*3] += (Math.random() - 0.5) / 2;
						allpointPositions.array[i*3+1] += (Math.random() - 0.5) / 10;
						allpointPositions.array[i*3+2] += (Math.random() - 0.5) / 2;
					}

    	            child.add( childePoints );
         	    	points.push(childePoints) ;

					// override wing shader
	                var wingMaterial = new THREE.MeshBasicMaterial({
    	                color: 0x00ffff,
        	            wireframe: true,
            	        visible: false
 					});
		  			child.material = wingMaterial;
	
				} else {
		  			/*
                	var material = new THREE.PointsMaterial( {
                    	color: 0xb9fff9,
                    	size: 0.02,
                    	map: null
                	} );

                	// points
                	var childePoints = new THREE.Points( geometry, material )
    	            child.add( childePoints );
         	    	points.push(childePoints) ;
		  			*/
				}
			}


			var growingPoints = 0;
            var sinTimer = 0;
            function step(delta) {
			    if (butterfly) {
			        var index = 0;
                    butterfly.traverse( function ( child ) {
                        if ( child.isMesh && points[index]) {
							var positions = points[index].geometry.attributes.position;
                            var rotation = points[index].geometry.attributes.rotation;
							var colors = points[index].geometry.attributes.color;
		  					var color = new THREE.Color();
							var count = positions.count;


                            points[index].material.size = 0.05;

                            if (growingPoints < 0.05) {
                                growingPoints += 0.00005;
							}

							for ( var j = 0; j < count; j ++ ) {
								color.setRGB(colors.getX(j), colors.getY(j), colors.getZ(j));
		  						color.offsetHSL(Math.abs(Math.sin(sinTimer/100))/100, 0., 0.);
								colors.setX( j, color.r );
								colors.setY( j, color.g );
								colors.setZ( j, color.b );

                                //positions.setX( j, positions.getX( j ) + Math.sin(sinTimer/100) * 0.1);
							}

                            sinTimer += 1;
							if (sinTimer > 1000000){
								sinTimer = 0;
							}

							positions.needsUpdate = true; // important!
							colors.needsUpdate = true;

                            index ++;
                        }

                    } );
				}

            }

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}


			var timer = 0;
			function animate() {
                requestAnimationFrame( animate );
                var delta = clock.getDelta();
                step(delta);
				if ( mixer ) {
				    mixer.update( delta );
                } else {
				}

				camera.near = 0.01;
				camera.far = 10000;
				camera.updateProjectionMatrix();

                setTimeline(timer);

                composer.render();


                timer += 0.1;
			}

            var afterimagePassStrength = 0;
			function setTimeline (timer) {
				var soundTime = sound.context.currentTime - sound.startTime;

				if (soundTime > timeline[0].startTime && !timeline[0].activated) {
                    console.log('dotts added');

                    glitchPass = new THREE.GlitchPass();
                    composer.addPass( glitchPass );
                    glitchPass.goWild = true;

                    addDottsToButterfly();
                    timeline[0].activated = true;
				}

                if (soundTime > timeline[1].startTime && !timeline[1].activated) {
                    afterimagePass.enabled = false;
                    bloomPass.enabled = false;
                    removeGlitch(timeline[1]);
                }

                if (soundTime > timeline[2].startTime && !timeline[2].activated) {
                    afterimagePass.enabled = true;
                    bloomPass.enabled = true;

                    setAfterimagePassStrength ();
                }

                if (afterimagePassStrength >=  1) {
                    addGlitch(timeline[3])
                }
            }

            function setAfterimagePassStrength () {
                afterimagePass.uniforms.damp.value = afterimagePassStrength;

                afterimagePassStrength += 0.002;
            }

            function addGlitch (timeToggle) {
                glitchPass.enabled = true;
                timeToggle.activated = true;
            }

            function removeGlitch (timeToggle) {
                glitchPass.enabled = false;
                timeToggle.activated = true;
            }

            function addDottsToButterfly () {
			    if (butterfly) {
                    butterfly.traverse( function ( child ) {
                        if ( child.isMesh ) {
                            var pointArray = child.geometry.attributes.position;
                            placePoints(pointArray, child);
                        }
                    } );
				}


            }

		</script>
	</body>
</html>

